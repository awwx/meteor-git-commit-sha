// Generated by CoffeeScript 1.4.0
(function() {
  var fetch_sha, git_sha, in_git_directory, index_differences, sha, spawn, wait_on_promise, working_tree_differences, _when;

  spawn = __meteor_bootstrap__.require('child_process').spawn;

  _when = this.when;

  in_git_directory = function() {
    var result;
    result = _when.defer();
    spawn('git', ['rev-parse', '--git-dir'], {
      stdio: 'ignore'
    }).on('exit', function(code) {
      return result.resolve(code === 0);
    });
    return result.promise;
  };

  index_differences = function() {
    var result;
    result = _when.defer();
    spawn('git', ['diff-index', '--quiet', 'HEAD'], {
      stdio: 'inherit'
    }).on('exit', function(code) {
      switch (code) {
        case 0:
          return result.resolve(false);
        case 1:
          return result.resolve(true);
        default:
          return result.reject('unable to run git-diff-index');
      }
    });
    return result.promise;
  };

  working_tree_differences = function() {
    var result;
    result = _when.defer();
    spawn('git', ['diff-files', '--quiet'], {
      stdio: 'inherit'
    }).on('exit', function(code) {
      return result.resolve(code !== 0);
    });
    return result.promise;
  };

  git_sha = function() {
    var process, result, sha;
    result = _when.defer();
    process = spawn('git', ['rev-parse', 'HEAD'], {
      stdio: ['ignore', 'pipe', 2]
    });
    sha = '';
    process.stdout.on('data', function(data) {
      return sha += data;
    });
    process.stdout.on('end', function() {
      sha = sha.trim();
      if (sha.length === 40) {
        return result.resolve(sha);
      } else {
        return result.reject('unable to determine HEAD commit sha with git-rev-parse');
      }
    });
    return result.promise;
  };

  fetch_sha = function() {
    return in_git_directory().then(function(in_git) {
      if (in_git) {
        return _when.all([git_sha(), index_differences(), working_tree_differences()], (function(_arg) {
          var index_modified, sha, working_tree_modified;
          sha = _arg[0], index_modified = _arg[1], working_tree_modified = _arg[2];
          if (index_modified || working_tree_modified) {
            sha = sha + ' (modified)';
          }
          return sha;
        }));
      } else {
        return null;
      }
    });
  };

  wait_on_promise = function(promise) {
    var fiber;
    fiber = Fiber.current;
    promise.then((function(result) {
      return fiber.run(result);
    }), (function(reason) {
      console.log(reason);
      return process.exit(1);
    }));
    return Fiber["yield"]();
  };

  sha = wait_on_promise(fetch_sha());

  __meteor_runtime_config__.git_commit = sha;

}).call(this);
